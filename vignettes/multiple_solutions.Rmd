---
title: "Multiple solutions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Multiple solutions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

[learnr]: https://rstudio.github.io/learnr/

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  message = FALSE,
  comment = "#>"
)

library(gradethis)
fibonacci <- c(0, 1, 1, 2, 3, 5, 8, 13, 21, 34)

grade_html <- function(grade) {
  htmltools::tags$div(
    role = "alert",
    class = if (!length(grade$correct)) {
      "alert" 
    } else if (isTRUE(grade$correct)) {
      "alert alert-success"
    } else {
      "alert alert-danger"
    },
    htmltools::HTML(commonmark::markdown_html(grade$message))
  )
}
```

```{css echo=FALSE, eval = !identical(Sys.getenv("IN_PKGDOWN", "false"), "true")}
.alert {
  padding: 0.5em 1em;
  margin: 1em 2em;
  border: 1px #eee solid;
  border-radius: 5px;
}
.alert.alert-success {
  background-color: #e4f2dc;
  border-color: #ddedcf;
}
.alert.alert-success,
.alert.alert-success code,
.alert.alert-success code a:not(.close):not(.btn) {
  color: #5c9653;
}
.alert.alert-danger {
  background-color: #f2e2e2;
  border-color: #eed9dc;
}
.alert.alert-danger,
.alert.alert-danger code,
.alert.alert-danger code a:not(.close):not(.btn) {
  color: #ad3532;
}
.alert code {
  background-color: #ffffff55;
}
```
```{css echo=FALSE}
.alert :last-child {
  margin-bottom: 0;
}
```

## Overview

Not all exercises have exactly one right answer:
there could be a few different ways to arrive at the same result,
or the exercise prompt could be open-ended and ask the student to pick from a selection of possibilities.
In either case, and with minimal changes to your learnr tutorial,
gradethis can accommodate exercises with multiple solutions!

There are two types of exercises with multiple solutions.
Some exercises include multiple ways of reaching the same result.
In these exercises, multiple solutions are just used for providing code feedback.
For more details on grading exercises where all solutions have the same result, see [Multiple solutions, same result](#same-result) below.

Other exercises have more than one acceptable result.
In these exercises, multiple solutions are used both for grading students' results and for providing code feedback.
For more details on grading exercises where there are multiple acceptable results, see [Multiple solutions, multiple results](#multiple-results) below.

But regardless of how many results your exercise has, you can setup your exercise the same way:

## Setup

To signal that your exercise has multiple solutions, you can separate each solution in the exercise's `-solution` chunk with code headers.

A code header is a comment followed by at least four dashes:

```markdown
# code header ----
```

Your exercise code should look something like this:

````markdown
```{r setup}`r ''`
library(learnr)
library(gradethis)
fibonacci <- c(0, 1, 1, 2, 3, 5, 8, 13, 21, 34)
```

Use `mean()` or `median()` to find the average of `fibonacci`, a vector containing the first 10 numbers in the Fibonacci sequence.

```{r average, exercise = TRUE}`r ''`
____(fibonacci)
```

```{r average-solution}`r ''`
# mean ----
mean(fibonacci)
# median ----
median(fibonacci)
```
````

## Multiple solutions, same result {#same-result}

If all your solutions have the same result, you don't need to do anything special in your grading code.
Multiple solution code is saved in a list called `.solution_code_all`, and gradethis functions that use solution code, like `code_feedback()` or `fail(hint = TRUE)`, will automatically give feedback based on the closest solution to the student's input.

### Example

````markdown
```{r setup}`r ''`
library(learnr)
library(gradethis)
```

Round 5.2 to the nearest whole number.

```{r round, exercise = TRUE}`r ''`
____(5.2)
```

```{r round-solution}`r ''`
# round ----
round(5.2)
# floor ----
floor(5.2)
```

```{r round-check}`r ''`
grade_this({
  pass_if_equal()
  fail(hint = TRUE)
})
```
````

If a student gives an incorrect answer using `round()`, code feedback will nudge them towards the correct `round()` solution:

```{r round_wrong, eval = FALSE}
round(5.2, digits = 1)
```

```{r echo = FALSE}
solution_code <- "
# round ----
round(5.2)
# floor ----
floor(5.2)"

grader <- grade_this({
  pass_if_equal()
  fail(hint = TRUE)
})

user_code <- paste(knitr::knit_code$get()$round_wrong, collapse = "\n")

grade_html(grader(mock_this_exercise(!!user_code, !!solution_code)))
```

And if a student gives an incorrect answer but their text is closer to `floor()`, code feedback will nudge them towards the correct `floor()` solution:

```{r floor_wrong, eval = FALSE}
flor(5.2)
```

```{r echo = FALSE}
user_code <- paste(knitr::knit_code$get()$floor_wrong, collapse = "\n")

grade_html(grader(mock_this_exercise(!!user_code, !!solution_code)))
```

### Providing different messages for different solutions

In some cases, you may want to accept multiple solutions, but give different feedback depending on the solution the student gave.
You can use code like the following template to give a special message for user input that matches a particular solution:
```{r eval = FALSE}
pass_if(
  is.null(code_feedback(solution_code = .solution_code_all[["<<chunk label>>"]])),
  "<< message >>"
)
```

Using `is.null(code_feedback(...))` is a robust way of testing if user code matches a solution code, because it ignores minor differences like spacing or whether the code uses pipes.

#### Example

````markdown
```{r round-check}`r ''`
grade_this({
  pass_if(
    is.null(code_feedback(solution_code = .solution_code_all[["floor"]])),
    "Correct, but remember that `floor()` always rounds down.
    If you want to round to the nearest whole number, `round()` is usually safer."
  )
  pass_if_equal()
  fail(hint = TRUE)
})
```
````

```{r floor_right, eval = FALSE}
floor(5.2)
```

```{r echo = FALSE}
grader <- grade_this({
  pass_if(
    is.null(code_feedback(solution_code = .solution_code_all[["floor"]])),
    "Correct, but remember that `floor()` always rounds down.
    If you want to round to the closest whole number, `round()` is usually safer."
  )
  pass_if_equal()
  fail(hint = TRUE)
})

user_code <- paste(knitr::knit_code$get()$floor_right, collapse = "\n")

grade_html(grader(mock_this_exercise(!!user_code, !!solution_code)))
```

## Multiple solutions, multiple results {#multiple-results}

If your exercise has multiple acceptable results, you'll need to slightly adapt your code to ensure students' inputs are tested against all acceptable results.
Multiple solution results are saved in an environment called `.solution_all`.
(Because `.solution_all` is an environment, it requires some special handling. Check [Working with `.solution_all`](#working-with-.solution_all) for more details.)

To compare student input to each solution, you should use `.solution_all` as the first argument in `pass_if_equal()`.
Within `pass_if_equal()` messages, you can use the object `.solution_label`, which corresponds to the code header of the solution that the student's code matched.

Functions that grade students' code can still be used without any changes.

### Example

````markdown
```{r setup}`r ''`
library(learnr)
library(gradethis)
fibonacci <- c(0, 1, 1, 2, 3, 5, 8, 13, 21, 34)
```

Use `mean()` or `median()` to find the average of `fibonacci`, a vector containing the first 10 numbers in the Fibonacci sequence.

```{r average, exercise = TRUE}`r ''`
____(fibonacci)
```

```{r average-solution}`r ''`
# mean ----
mean(fibonacci)
# median ----
median(fibonacci)
```

```{r average-check}`r ''`
pass_if_equal(.solution_all, "You solved it with {.solution_label}()!")
fail(hint = TRUE)
```
````

If a student gives either correct solution, `pass_if_equal()` will give them a passing grade:

```{r mean_right, eval = FALSE}
mean(fibonacci)
```

```{r echo = FALSE}
solution_code <- "
# mean ----
mean(fibonacci)
# median ----
median(fibonacci)"

grader <- grade_this({
  pass_if_equal(.solution_all, "You solved it with `{.solution_label}()`!")
  fail(hint = TRUE)
})

user_code <- paste(knitr::knit_code$get()$mean_right, collapse = "\n")

grade_html(grader(mock_this_exercise(!!user_code, !!solution_code)))
```

```{r median_right, eval = FALSE}
median(fibonacci)
```

```{r echo = FALSE}
user_code <- paste(knitr::knit_code$get()$median_right, collapse = "\n")
grade_html(grader(mock_this_exercise(!!user_code, !!solution_code)))
```

If the student's input doesn't match any of the solutions, grading will proceed as normal:

```{r sum_wrong, eval = FALSE}
sum(fibonacci)
```

```{r echo = FALSE}
user_code <- paste(knitr::knit_code$get()$sum_wrong, collapse = "\n")
grade_html(grader(mock_this_exercise(!!user_code, !!solution_code)))
```

### Working with `.solution_all`

`.solution_all` is an environment, not a list.
This carries certain advantages.
Exercises can be graded faster because each solution can be evaluated as needed rather than all up front.

But it also comes with drawbacks.
The most important are:

1. environments can't be subset with numbers, only names, and
2. all elements of an environment need to have a unique name.

To make life easy, make sure you give a label to every solution, and that you don't duplicate labels for more than one solution. Like this:
```{r eval = FALSE}
# mean ----
mean(fibonacci)
# mean with na.rm ----
mean(fibonacci, na.rm = TRUE)
# median ----
median(fibonacci)
# median with na.rm ----
median(fibonacci, na.rm = TRUE)
```
And not like this:
```{r eval = FALSE}
# mean ----
mean(fibonacci)
# mean ----
mean(fibonacci, na.rm = TRUE)
# median ----
median(fibonacci)
# median ----
median(fibonacci, na.rm = TRUE)
```

If you need to reference a specific solution result in grading code, you can access the `.solution_all` object by name, like this:

```{r eval = FALSE}
grade_this({
  pass_if_equal(
    .solution_all[["mean"]],
    "That's right! Do you think the mean is skewed?"
  )
  pass_if_equal(.solution_all)
  fail_if_code_feedback()
  fail()
})
```

#### Working with `.solution_all` without unique names

If you don't give your solutions unique names, `gradethis` will generate unique names for you. For example, these solutions

```{r nonunique_names, eval = FALSE}
# mean ----
mean(fibonacci)
# mean ----
mean(fibonacci, na.rm = TRUE)
# mean ----
mean(fibonacci, na.rm = FALSE)
# median ----
median(fibonacci)
# median ----
median(fibonacci, na.rm = TRUE)
# median ----
median(fibonacci, na.rm = FALSE)
```

have these names:

```{r echo = FALSE}
solution_code <- paste(knitr::knit_code$get()$nonunique_names, collapse = "\n")
ex <- mock_this_exercise(.user_code = "", .solution_code = !!solution_code)
ls(ex$.solution_all)
```

If you need to access specific solution results in your grading code, it's almost always better to give your solutions unique labels.

The one reason you may want to use duplicate labels is if you use `.solution_label` in your code.
The `.solution_label` object will still work with the labels you define, not the object names generated by `gradethis`:

````markdown
```{r setup}`r ''`
library(learnr)
library(gradethis)
fibonacci <- c(0, 1, 1, 2, 3, 5, 8, 13, 21, 34)
```

Use `mean()` or `median()` to find the average of `fibonacci`, a vector containing the first 10 numbers in the Fibonacci sequence.

```{r average, exercise = TRUE}`r ''`
____(fibonacci)
```

```{r average-solution}`r ''`
# mean ----
mean(fibonacci)
# mean ----
mean(fibonacci, na.rm = TRUE)
# mean ----
mean(fibonacci, na.rm = FALSE)
# median ----
median(fibonacci)
# median ----
median(fibonacci, na.rm = TRUE)
# median ----
median(fibonacci, na.rm = FALSE)
```

```{r average-check}`r ''`
pass_if_equal(.solution_all, "You solved it with {.solution_label}()!")
fail(hint = TRUE)
```
````

```{r median_right_2, eval = FALSE}
median(fibonacci, na.rm = TRUE)
```

```{r echo = FALSE}
solution_code <- "# mean ----
mean(fibonacci)
# mean ----
mean(fibonacci, na.rm = TRUE)
# mean ----
mean(fibonacci, na.rm = FALSE)
# median ----
median(fibonacci)
# median ----
median(fibonacci, na.rm = TRUE)
# median ----
median(fibonacci, na.rm = FALSE)"

grader <- grade_this({
  pass_if_equal(.solution_all, "You solved it with `{.solution_label}()`!")
  fail(hint = TRUE)
})

user_code <- paste(knitr::knit_code$get()$median_right_2, collapse = "\n")

grade_html(grader(mock_this_exercise(!!user_code, !!solution_code)))
```
